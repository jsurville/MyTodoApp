import { __decorate, __metadata, __param } from 'tslib';
import { Injectable, ɵɵdefineInjectable, ɵɵinject, EventEmitter, Input, HostBinding, Output, HostListener, Directive, ElementRef, Renderer2, Optional, Inject, ContentChildren, QueryList, SkipSelf, Component, NgModuleFactory, ComponentFactoryResolver, ViewContainerRef, Compiler, ContentChild, TemplateRef, Type, ChangeDetectionStrategy, Self, NgModule } from '@angular/core';
import { Location, PlatformLocation, LocationStrategy, PathLocationStrategy, CommonModule } from '@angular/common';
import { Observable, BehaviorSubject, Subject, of, combineLatest, from } from 'rxjs';
import { map, distinctUntilChanged, filter, takeUntil, startWith, mapTo, debounceTime, tap, withLatestFrom, mergeMap } from 'rxjs/operators';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["*"];
function RouteComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 1);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r0.template);
} }
let UrlParser = class UrlParser {
    parse(url, base) {
        if (base) {
            return new URL(url, base);
        }
        return new URL(url);
    }
    joinUrls(currentUrl, url) {
        const currentUrlSegments = currentUrl
            .split('#')[0] // remove hash
            .split('?')[0] // remove query params
            .split('/');
        const urlSegments = url.split('/');
        return urlSegments
            .reduce((segments, segment) => {
            if (segment === '.') {
                return segments;
            }
            if (segment === '..') {
                return segments.slice(0, -1);
            }
            return [...segments, segment];
        }, currentUrlSegments)
            .join('/');
    }
};
UrlParser.ɵfac = function UrlParser_Factory(t) { return new (t || UrlParser)(); };
UrlParser.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: UrlParser, factory: function (t) { return UrlParser.ɵfac(t); } });

class RoutePath extends Observable {
}
class RouteParams extends Observable {
}
class QueryParams extends Observable {
}
function compareParams(previous, current) {
    return (previous === current || JSON.stringify(previous) === JSON.stringify(current));
}

let Router = class Router {
    constructor(location, platformLocation, urlParser) {
        this.location = location;
        this.platformLocation = platformLocation;
        this.urlParser = urlParser;
        this.state$ = new BehaviorSubject({
            url: this.location.path(),
            queryParams: {},
            hash: '',
        });
        this.url$ = this.state$.pipe(map((state) => state.url), distinctUntilChanged());
        this.hash$ = this.state$.pipe(map((state) => state.hash), distinctUntilChanged());
        this.queryParams$ = this.state$.pipe(map((state) => state.queryParams), distinctUntilChanged(compareParams));
        this.location.subscribe(() => {
            this.nextState(this.getLocation());
        });
        this.nextState(this.getLocation());
    }
    forward() {
        this.location.forward();
        this.nextState(this.getLocation());
    }
    back() {
        this.location.back();
        this.nextState(this.getLocation());
    }
    go(url, queryParams, hash) {
        this.location.go(this.serializeUrl(url, queryParams, hash));
        this.nextState(this.getLocation());
    }
    replace(url, queryParams, hash) {
        this.location.replaceState(this.serializeUrl(url, queryParams, hash));
        this.nextState(this.getLocation());
    }
    serializeUrl(url, queryParams, hash) {
        // if relative path
        if (!url.startsWith('/')) {
            url = this.urlParser.joinUrls(this.location.path(), url);
        }
        return (url +
            (queryParams ? `?${this.stringifyQueryParams(queryParams)}` : '') +
            `${hash ? '#' + hash : ''}`);
    }
    getExternalUrl(url) {
        return this.location.prepareExternalUrl(url);
    }
    parseSearchParams(params) {
        const searchParams = new URLSearchParams(params);
        const queryParams = {};
        searchParams.forEach((value, key) => {
            queryParams[key] = value;
        });
        return queryParams;
    }
    normalizePath(path) {
        return this.location.normalize(path);
    }
    getLocation() {
        return this.platformLocation.href;
    }
    nextState(url) {
        const parsedUrl = this._parseUrl(url);
        this.state$.next({
            url: parsedUrl.pathname,
            queryParams: this.parseSearchParams(parsedUrl.searchParams),
            hash: parsedUrl.hash ? parsedUrl.hash.split('#')[1] : '',
        });
    }
    _parseUrl(path) {
        return this.urlParser.parse(path);
    }
    stringifyQueryParams(params) {
        return new URLSearchParams(params).toString();
    }
};
Router.ɵfac = function Router_Factory(t) { return new (t || Router)(ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(ɵngcc1.PlatformLocation), ɵngcc0.ɵɵinject(UrlParser)); };
Router.ctorParameters = () => [
    { type: Location },
    { type: PlatformLocation },
    { type: UrlParser }
];
Router.ɵprov = ɵɵdefineInjectable({ factory: function Router_Factory() { return new Router(ɵɵinject(Location), ɵɵinject(PlatformLocation), ɵɵinject(UrlParser)); }, token: Router, providedIn: "root" });
Router = __decorate([ __metadata("design:paramtypes", [Location,
        PlatformLocation,
        UrlParser])
], Router);

const DEFAULT_TARGET = '_self';
/**
 * The LinkTo directive links to routes in your app
 *
 * Links are pushed to the `Router` service to trigger a route change.
 * Query params can be represented as an object or a string of names/values
 *
 * <a linkTo="/home/page" [queryParams]="{ id: 123 }">Home Page</a>
 * <a [linkTo]="'/pages' + page.id">Page 1</a>
 */
let LinkTo = class LinkTo {
    constructor(router) {
        this.router = router;
        this.target = DEFAULT_TARGET;
        this.hrefUpdated = new EventEmitter();
    }
    set linkTo(href) {
        if (href === null || href === undefined) {
            return;
        }
        this._href = href;
        this._updateHref();
    }
    set queryParams(params) {
        this._query = params;
        this._updateHref();
    }
    set fragment(hash) {
        this._hash = hash;
        this._updateHref();
    }
    /**
     * Handles click events on the associated link
     * Prevents default action for non-combination click events without a target
     */
    onClick(event) {
        if (!this._href) {
            return;
        }
        if (!this._comboClick(event) && this.target === DEFAULT_TARGET) {
            this.router.go(this._href, this._query, this._hash);
            event.preventDefault();
        }
    }
    _updateHref() {
        const href = this._cleanUpHref(this._href);
        this.linkHref = this.router.serializeUrl(href, this._query, this._hash);
        this.hrefUpdated.emit(this.linkHref);
    }
    /**
     * Determines whether the click event happened with a combination of other keys
     */
    _comboClick(event) {
        const buttonEvent = event.which || event.button;
        return buttonEvent > 1 || event.ctrlKey || event.metaKey || event.shiftKey;
    }
    _cleanUpHref(href = '') {
        // Trim whitespaces and remove trailing slashes
        return href.trim().replace(/(?!^)\/+$/, '');
    }
};
LinkTo.ɵfac = function LinkTo_Factory(t) { return new (t || LinkTo)(ɵngcc0.ɵɵdirectiveInject(Router)); };
LinkTo.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LinkTo, selectors: [["a", "linkTo", ""]], hostVars: 1, hostBindings: function LinkTo_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function LinkTo_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("href", ctx.linkHref, ɵngcc0.ɵɵsanitizeUrl);
    } }, inputs: { target: "target", linkTo: "linkTo", queryParams: "queryParams", fragment: "fragment" }, outputs: { hrefUpdated: "hrefUpdated" } });
LinkTo.ctorParameters = () => [
    { type: Router }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], LinkTo.prototype, "target", void 0);
__decorate([
    HostBinding('href'),
    __metadata("design:type", String)
], LinkTo.prototype, "linkHref", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], LinkTo.prototype, "linkTo", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], LinkTo.prototype, "queryParams", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], LinkTo.prototype, "fragment", null);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], LinkTo.prototype, "hrefUpdated", void 0);
__decorate([
    HostListener('click', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], LinkTo.prototype, "onClick", null);
LinkTo = __decorate([ __metadata("design:paramtypes", [Router])
], LinkTo);

function isNotNullable(it) {
    return it !== null && it !== undefined;
}
const filterNullable = () => (source) => source.pipe(filter(isNotNullable));

const LINK_ACTIVE_OPTIONS = {
    exact: true,
};
/**
 * The LinkActive directive toggles classes on elements that contain an active linkTo directive
 *
 * <a linkActive="active" linkTo="/home/page">Home Page</a>
 * <ol>
 *  <li linkActive="active" *ngFor="var link of links">
 *    <a [linkTo]="'/link/' + link.id">{{ link.title }}</a>
 *  </li>
 * </ol>
 */
let LinkActive = class LinkActive {
    constructor(element, router, renderer, defaultActiveOptions, link) {
        this.element = element;
        this.router = router;
        this.renderer = renderer;
        this.defaultActiveOptions = defaultActiveOptions;
        this.link = link;
        this.activeClass = 'active';
        this._activeOptions = { exact: true };
        this._destroy$ = new Subject();
    }
    ngAfterContentInit() {
        if (this.defaultActiveOptions && !this.activeOptions) {
            this._activeOptions = this.defaultActiveOptions;
        }
        else if (this.activeOptions) {
            this._activeOptions = this.activeOptions;
        }
        this.links.changes
            .pipe(takeUntil(this._destroy$))
            .subscribe(() => this.collectLinks());
        this.collectLinks();
    }
    ngOnChanges() {
        this.collectLinks();
    }
    collectLinks() {
        if (this._linksSub) {
            this._linksSub.unsubscribe();
        }
        const contentLinks$ = this.links
            ? this.links
                .toArray()
                .map((link) => link.hrefUpdated.pipe(startWith(link.linkHref), mapTo(link.linkHref), filterNullable()))
            : [];
        const link$ = this.link
            ? this.link.hrefUpdated.pipe(startWith(this.link.linkHref), mapTo(this.link.linkHref), filterNullable())
            : of('');
        const router$ = this.router.url$.pipe(map((path) => this.router.getExternalUrl(path || '/')));
        const observables$ = [router$, link$, ...contentLinks$];
        this._linksSub = combineLatest(observables$)
            .pipe(takeUntil(this._destroy$))
            .subscribe(([path, link, ...links]) => {
            this.checkActive([...links, link], path);
        });
    }
    checkActive(linkHrefs, path) {
        const active = linkHrefs.reduce((isActive, current) => {
            const [href] = current.split('?');
            if (this._activeOptions.exact) {
                return isActive ? isActive : href === path;
            }
            return isActive ? isActive : path.startsWith(href);
        }, false);
        this.updateClasses(active);
    }
    updateClasses(active) {
        const activeClasses = this.activeClass.split(' ');
        activeClasses.forEach((activeClass) => {
            if (active) {
                this.renderer.addClass(this.element.nativeElement, activeClass);
            }
            else {
                this.renderer.removeClass(this.element.nativeElement, activeClass);
            }
        });
    }
    ngOnDestroy() {
        this._destroy$.next();
    }
};
LinkActive.ɵfac = function LinkActive_Factory(t) { return new (t || LinkActive)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(LINK_ACTIVE_OPTIONS, 8), ɵngcc0.ɵɵdirectiveInject(LinkTo, 8)); };
LinkActive.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LinkActive, selectors: [["", "linkActive", ""]], contentQueries: function LinkActive_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, LinkTo, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.links = _t);
    } }, inputs: { activeClass: ["linkActive", "activeClass"], activeOptions: "activeOptions" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
LinkActive.ctorParameters = () => [
    { type: ElementRef },
    { type: Router },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LINK_ACTIVE_OPTIONS,] }] },
    { type: LinkTo, decorators: [{ type: Optional }] }
];
__decorate([
    ContentChildren(LinkTo, { descendants: true }),
    __metadata("design:type", QueryList)
], LinkActive.prototype, "links", void 0);
__decorate([
    Input('linkActive'),
    __metadata("design:type", String)
], LinkActive.prototype, "activeClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LinkActive.prototype, "activeOptions", void 0);
LinkActive = __decorate([ __param(3, Optional()),
    __param(3, Inject(LINK_ACTIVE_OPTIONS)),
    __param(4, Optional()),
    __metadata("design:paramtypes", [ElementRef,
        Router,
        Renderer2, Object, LinkTo])
], LinkActive);

let RouteComponentTemplate = class RouteComponentTemplate {
};
RouteComponentTemplate.ɵfac = function RouteComponentTemplate_Factory(t) { return new (t || RouteComponentTemplate)(); };
RouteComponentTemplate.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RouteComponentTemplate, selectors: [["", "routeComponent", ""]], inputs: { routeComponent: "routeComponent" } });
__decorate([
    Input(),
    __metadata("design:type", Object)
], RouteComponentTemplate.prototype, "routeComponent", void 0);

const PARAM_PREFIX = ':';
const DIV = '\\/'; // /
const DIV_PARAM = `(?:${DIV}([^\\/#\\?]+?))`; // capturing group for one or more of not (/, # or ?), optional (TODO: check if optional is needed)
const PATH_END = '[\\/#\\?]'; // path end: /, # or ?
const END = '[]|$'; // null or end
const EXACT_END = `${PATH_END}?$`; // match PATH_END optionally and END
const WILDCARD = `(?:${PATH_END}(?=${END}))?`; // match optionally PATH_END followed by END
const NON_EXACT_END = `${WILDCARD}(?=${PATH_END}|${END})`; // match WILDCARD followed by PATH_END or END
function getPathSegments(route) {
    const sanitizedPath = route.path.replace(/^\//, '').replace(/(?:\/$)/, '');
    return sanitizedPath ? sanitizedPath.split('/') : [];
}
const parsePath = (route) => {
    var _a;
    const segments = getPathSegments(route);
    const regexBody = segments.reduce((acc, segment) => segment.startsWith(PARAM_PREFIX)
        ? `${acc}${DIV_PARAM}`
        : `${acc}${DIV}${segment}`, '');
    if ((_a = route.options.exact) !== null && _a !== void 0 ? _a : true) {
        return new RegExp(`^${regexBody}${EXACT_END}`, 'i');
    }
    else {
        return new RegExp(`^${regexBody}${regexBody ? NON_EXACT_END : WILDCARD}`, 'i');
    }
};
const matchRoute = (url, route) => {
    var _a;
    const match = (_a = route.matcher) === null || _a === void 0 ? void 0 : _a.exec(url);
    if (!match) {
        return;
    }
    const keys = getPathSegments(route)
        .filter((s) => s.startsWith(PARAM_PREFIX))
        .map((s) => s.slice(1));
    return {
        path: match[0],
        params: keys.reduce((acc, key, index) => (Object.assign(Object.assign({}, acc), { [key]: match[index + 1] })), {}),
    };
};

/**
 * Compares two routes and returns sorting number
 * 0 - equal
 * -1 - `a` has priority over `b`
 * 1 - `b` has priority over `a`
 *
 * @param a Route
 * @param b Route
 */
const compareRoutes = (a, b) => {
    var _a;
    // as matchers combine normalized path and `exact` option it's safe to compare regexps
    if (a.matcher.toString() === b.matcher.toString()) {
        return 0;
    }
    const aSegments = getPathSegments(a);
    const bSegments = getPathSegments(b);
    for (let i = 0; i < Math.max(aSegments.length, bSegments.length); i++) {
        const current = compareSegments(aSegments, bSegments, i);
        if (current) {
            return current;
        }
    }
    // when paths are same, exact has priority
    return ((_a = a.options.exact) !== null && _a !== void 0 ? _a : true) ? -1 : 1;
};
function compareSegments(aSegments, bSegments, index) {
    // if a has no more segments -> return 1
    if (aSegments.length <= index) {
        return 1;
    }
    // if b has no more segments -> return -1
    if (bSegments.length <= index) {
        return -1;
    }
    if (aSegments[index] === bSegments[index]) {
        return 0;
    }
    // prioritize non-empty path over empty
    if (!aSegments[index]) {
        return 1;
    }
    if (!bSegments[index]) {
        return -1;
    }
    // ignore param names
    if (isParam(aSegments[index]) && isParam(bSegments[index])) {
        return 0;
    }
    // static segment has priority over param
    if (isParam(aSegments[index])) {
        return 1;
    }
    if (isParam(bSegments[index])) {
        return -1;
    }
    // when all is same run string comparison
    return aSegments[index].localeCompare(bSegments[index]);
}
function isParam(segment) {
    return segment.startsWith(':');
}

let RouterComponent = class RouterComponent {
    // support multiple "routers"
    // router (base /)
    // blog(.*?)
    // router (base /blog)
    // post1(blog/post1/(.*?)
    // post2
    // post3
    constructor(router, parentRouterComponent) {
        this.router = router;
        this.parentRouterComponent = parentRouterComponent;
        this.destroy$ = new Subject();
        this.state$ = new BehaviorSubject({
            activeRoute: null,
            routes: [],
        });
        this.activeRoute$ = this.state$.pipe(map((state) => state.activeRoute), distinctUntilChanged(this.compareActiveRoutes), takeUntil(this.destroy$));
        this.routes$ = this.state$.pipe(map((state) => state.routes), distinctUntilChanged(this.compareRoutes), takeUntil(this.destroy$));
        this.basePath = '';
    }
    ngOnInit() {
        combineLatest([this.routes$.pipe(debounceTime(1)), this.router.url$])
            .pipe(distinctUntilChanged(), tap(([routes, url]) => {
            let routeToRender = null;
            for (const route of routes) {
                routeToRender = this.isRouteMatch(url, route);
                if (routeToRender) {
                    this.setRoute(url, route);
                    break;
                }
            }
            if (!routeToRender) {
                this.setActiveRoute({ route: null, params: {}, path: '' });
            }
        }), takeUntil(this.destroy$))
            .subscribe();
    }
    setRoute(url, route) {
        this.basePath = route.path;
        const match = matchRoute(url, route);
        this.setActiveRoute({
            route,
            params: (match === null || match === void 0 ? void 0 : match.params) || {},
            path: (match === null || match === void 0 ? void 0 : match.path) || '',
        });
    }
    registerRoute(route) {
        route.matcher = route.matcher || parsePath(route);
        this.updateRoutes(route);
        return route;
    }
    setActiveRoute(activeRoute) {
        this.updateState({ activeRoute });
    }
    unregisterRoute(route) {
        this.updateRoutes(Object.assign(Object.assign({}, route), { unregister: true }));
    }
    normalizePath(path) {
        return this.router.normalizePath(path);
    }
    ngOnDestroy() {
        this.destroy$.next();
    }
    isRouteMatch(url, route) {
        var _a;
        return (_a = route.matcher) === null || _a === void 0 ? void 0 : _a.exec(url);
    }
    compareActiveRoutes(previous, current) {
        if (previous === current) {
            return true;
        }
        if (!previous) {
            return false;
        }
        return (previous.path === current.path &&
            compareParams(previous.params, current.params) &&
            previous.route.path === current.route.path &&
            previous.route.options.exact === current.route.options.exact);
    }
    compareRoutes(previous, current) {
        if (previous === current) {
            return true;
        }
        if (!previous) {
            return false;
        }
        return (previous.length === current.length &&
            previous.every((route, i) => route === current[i]));
    }
    updateState(newState) {
        this.state$.next(Object.assign(Object.assign({}, this.state$.value), newState));
    }
    updateRoutes(route) {
        const routes = this.state$.value.routes;
        if (route.unregister) {
            this.updateState({
                routes: routes.filter((r) => r.matcher !== route.matcher),
            });
        }
        else {
            this.updateState({ routes: routes.concat(route).sort(compareRoutes) });
        }
    }
};
RouterComponent.ɵfac = function RouterComponent_Factory(t) { return new (t || RouterComponent)(ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(RouterComponent, 12)); };
RouterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RouterComponent, selectors: [["router"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function RouterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
RouterComponent.ctorParameters = () => [
    { type: Router },
    { type: RouterComponent, decorators: [{ type: SkipSelf }, { type: Optional }] }
];
RouterComponent = __decorate([ __param(1, SkipSelf()), __param(1, Optional()),
    __metadata("design:paramtypes", [Router,
        RouterComponent])
], RouterComponent);

var RouteComponent_1;
function getRouteParams(routeComponent) {
    return routeComponent.routeParams$;
}
function getRoutePath(routeComponent) {
    return routeComponent.routePath$;
}
let RouteComponent = RouteComponent_1 = class RouteComponent {
    constructor(router, routerComponent, resolver, viewContainerRef, compiler) {
        this.router = router;
        this.routerComponent = routerComponent;
        this.resolver = resolver;
        this.viewContainerRef = viewContainerRef;
        this.compiler = compiler;
        this.reuse = true;
        this.destroy$ = new Subject();
        this.state$ = new BehaviorSubject({
            params: {},
            path: '',
            shouldRender: false,
        });
        this.shouldRender$ = this.state$.pipe(map((state) => state.shouldRender));
        this.routeParams$ = this.state$.pipe(map((state) => state.params), distinctUntilChanged(), takeUntil(this.destroy$));
        this.routePath$ = this.state$.pipe(map((state) => state.path), distinctUntilChanged(), takeUntil(this.destroy$));
    }
    get path() {
        return this._path;
    }
    set path(value) {
        this._path = this.sanitizePath(value);
    }
    ngOnInit() {
        // account for root level routes, don't add the basePath
        const path = this.routerComponent.parentRouterComponent
            ? this.routerComponent.parentRouterComponent.basePath + this.path
            : this.path;
        this.route = this.registerRoute(path, this.exact, this.load);
        this.routerComponent.activeRoute$
            .pipe(filter((ar) => ar !== null), distinctUntilChanged(), withLatestFrom(this.shouldRender$), mergeMap(([current, rendered]) => {
            if (current.route === this.route) {
                if (this.redirectTo) {
                    this.router.go(this.redirectTo);
                    return of(null);
                }
                this.updateState({
                    params: current.params,
                    path: current.path,
                });
                if (!rendered) {
                    if (!this.reuse) {
                        this.clearView();
                    }
                    return this.loadAndRender(current.route);
                }
                return of(null);
            }
            else if (rendered) {
                return of(this.clearView());
            }
            return of(null);
        }), takeUntil(this.destroy$))
            .subscribe();
    }
    ngOnDestroy() {
        this.routerComponent.unregisterRoute(this.route);
        this.destroy$.next();
    }
    registerRoute(path, exact, load) {
        return this.routerComponent.registerRoute({
            path: path,
            load: load,
            options: this.routeOptions || { exact: exact },
        });
    }
    loadAndRender(route) {
        if (route.load) {
            return from(route.load().then((componentOrModule) => {
                if (componentOrModule instanceof NgModuleFactory) {
                    const moduleRef = componentOrModule.create(this.viewContainerRef.injector);
                    const component = moduleRef.instance.routeComponent;
                    this.renderComponent(component);
                }
                else if (componentOrModule.ɵmod) {
                    return this.compiler
                        .compileModuleAsync(componentOrModule)
                        .then((moduleFactory) => {
                        const moduleRef = moduleFactory.create(this.viewContainerRef.injector);
                        const component = moduleRef.instance.routeComponent;
                        this.renderComponent(component);
                        return true;
                    });
                }
                else {
                    this.renderComponent(componentOrModule);
                }
                return true;
            }));
        }
        else {
            this.showTemplate();
            return of(true);
        }
    }
    renderComponent(component) {
        const componentFactory = this.resolver.resolveComponentFactory(component);
        this.showTemplate();
        this.viewContainerRef.createComponent(componentFactory, this.viewContainerRef.length, this.viewContainerRef.injector);
    }
    clearComponent() {
        this.viewContainerRef.clear();
        this.hideTemplate();
    }
    showTemplate() {
        setTimeout(() => {
            this.updateState({ shouldRender: true });
        });
    }
    hideTemplate() {
        this.updateState({ shouldRender: false });
    }
    clearView() {
        if (this.load) {
            this.clearComponent();
        }
        else {
            this.hideTemplate();
        }
    }
    sanitizePath(path) {
        const trimmed = path.trim();
        return trimmed.startsWith('/') ? trimmed : `/${trimmed}`;
    }
    updateState(newState) {
        this.state$.next(Object.assign(Object.assign({}, this.state$.value), newState));
    }
};
RouteComponent.ɵfac = function RouteComponent_Factory(t) { return new (t || RouteComponent)(ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(RouterComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Compiler)); };
RouteComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RouteComponent, selectors: [["route"]], contentQueries: function RouteComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TemplateRef, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
    } }, inputs: { reuse: "reuse", path: "path", component: "component", load: "load", redirectTo: "redirectTo", exact: "exact", routeOptions: "routeOptions" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: RouteParams,
                useFactory: getRouteParams,
                deps: [[new Self(), RouteComponent_1]]
            },
            {
                provide: RoutePath,
                useFactory: getRoutePath,
                deps: [[new Self(), RouteComponent_1]]
            },
        ])], decls: 2, vars: 3, consts: [[3, "ngTemplateOutlet", 4, "ngIf"], [3, "ngTemplateOutlet"]], template: function RouteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, RouteComponent_ng_container_0_Template, 1, 1, "ng-container", 0);
        ɵngcc0.ɵɵpipe(1, "async");
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBind1(1, 1, ctx.shouldRender$) && ctx.template);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], pipes: [ɵngcc1.AsyncPipe], encapsulation: 2, changeDetection: 0 });
RouteComponent.ctorParameters = () => [
    { type: Router },
    { type: RouterComponent },
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef },
    { type: Compiler }
];
__decorate([
    ContentChild(TemplateRef),
    __metadata("design:type", TemplateRef)
], RouteComponent.prototype, "template", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], RouteComponent.prototype, "path", null);
__decorate([
    Input(),
    __metadata("design:type", Type)
], RouteComponent.prototype, "component", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], RouteComponent.prototype, "load", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RouteComponent.prototype, "reuse", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], RouteComponent.prototype, "redirectTo", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], RouteComponent.prototype, "exact", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], RouteComponent.prototype, "routeOptions", void 0);
RouteComponent = RouteComponent_1 = __decorate([ __metadata("design:paramtypes", [Router,
        RouterComponent,
        ComponentFactoryResolver,
        ViewContainerRef,
        Compiler])
], RouteComponent);

var ComponentRouterModule_1;
const components = [
    RouterComponent,
    RouteComponent,
    LinkActive,
    LinkTo,
    RouteComponentTemplate,
];
function getQueryParams(router) {
    return router.queryParams$;
}
let ComponentRouterModule = ComponentRouterModule_1 = class ComponentRouterModule {
    static forRoot() {
        return {
            ngModule: ComponentRouterModule_1,
            providers: [
                UrlParser,
                { provide: LocationStrategy, useClass: PathLocationStrategy },
                { provide: QueryParams, deps: [Router], useFactory: getQueryParams },
            ],
        };
    }
};
ComponentRouterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ComponentRouterModule });
ComponentRouterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ComponentRouterModule_Factory(t) { return new (t || ComponentRouterModule)(); }, imports: [[CommonModule]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(UrlParser, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Router, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.Location }, { type: ɵngcc1.PlatformLocation }, { type: UrlParser }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LinkTo, [{
        type: Directive,
        args: [{ selector: 'a[linkTo]' }]
    }], function () { return [{ type: Router }]; }, { target: [{
            type: Input
        }], hrefUpdated: [{
            type: Output
        }], linkTo: [{
            type: Input
        }], queryParams: [{
            type: Input
        }], fragment: [{
            type: Input
        }], 
    /**
     * Handles click events on the associated link
     * Prevents default action for non-combination click events without a target
     */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], linkHref: [{
            type: HostBinding,
            args: ['href']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LinkActive, [{
        type: Directive,
        args: [{ selector: '[linkActive]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: Router }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [LINK_ACTIVE_OPTIONS]
            }] }, { type: LinkTo, decorators: [{
                type: Optional
            }] }]; }, { activeClass: [{
            type: Input,
            args: ['linkActive']
        }], links: [{
            type: ContentChildren,
            args: [LinkTo, { descendants: true }]
        }], activeOptions: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouteComponentTemplate, [{
        type: Directive,
        args: [{
                selector: '[routeComponent]'
            }]
    }], null, { routeComponent: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterComponent, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'router',
                template: '<ng-content></ng-content>'
            }]
    }], function () { return [{ type: Router }, { type: RouterComponent, decorators: [{
                type: SkipSelf
            }, {
                type: Optional
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouteComponent, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'route',
                template: `
    <ng-container
      *ngIf="(shouldRender$ | async) && template"
      [ngTemplateOutlet]="template"
    >
    </ng-container>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: RouteParams,
                        useFactory: getRouteParams,
                        deps: [[new Self(), RouteComponent_1]]
                    },
                    {
                        provide: RoutePath,
                        useFactory: getRoutePath,
                        deps: [[new Self(), RouteComponent_1]]
                    },
                ]
            }]
    }], function () { return [{ type: Router }, { type: RouterComponent }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Compiler }]; }, { reuse: [{
            type: Input
        }], path: [{
            type: Input
        }], template: [{
            type: ContentChild,
            args: [TemplateRef]
        }], component: [{
            type: Input
        }], load: [{
            type: Input
        }], redirectTo: [{
            type: Input
        }], exact: [{
            type: Input
        }], routeOptions: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ComponentRouterModule, { declarations: function () { return [RouterComponent, RouteComponent, LinkActive, LinkTo, RouteComponentTemplate]; }, imports: function () { return [CommonModule]; }, exports: function () { return [RouterComponent, RouteComponent, LinkActive, LinkTo, RouteComponentTemplate]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ComponentRouterModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [components],
                exports: [components]
            }]
    }], null, null); })();

/*
 * Public API Surface of router
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ComponentRouterModule, LINK_ACTIVE_OPTIONS, LinkActive, LinkTo, QueryParams, RouteComponent, RouteComponentTemplate, RouteParams, RoutePath, Router, RouterComponent, UrlParser, compareParams, components, getQueryParams, getRouteParams, getRoutePath };

//# sourceMappingURL=angular-component-router.js.map